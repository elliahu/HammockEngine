#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D storageImage;

// Camera type
struct Camera {
    vec4 invView; // Inverse view matrix
    vec4 position; // Camera position in world space
    vec2 viewport; // Viewport dimensins
};

struct Sun {
    vec4 direction;
    vec4 color;
};

layout (binding = 1) uniform UBO
{
    Camera camera;
    Sun env;
} ubo;

layout (std140, binding = 2) buffer Scene
{
    float surfaceRadius;
    float atmosphereRadius;
} storageBuffer;

vec2 raySphereDst(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float disc = b * b - c;

    // No intersection: return zeros.
    if (disc < 0.0)
    return vec2(0.0, 0.0);

    float sqrtDisc = sqrt(disc);
    float t0 = -b - sqrtDisc;
    float t1 = -b + sqrtDisc;

    // If both intersections are behind the ray origin, treat as no intersection.
    if (t1 < 0.0)
    return vec2(0.0, 0.0);

    // If the ray starts inside the sphere, return 0 for distance to p1 and t1 as the chord.
    if (t0 < 0.0)
    return vec2(0.0, t1);

    // Otherwise, the ray starts outside the sphere.
    return vec2(t0, t1 - t0);
}

void main() {
    ivec2 dim = imageSize(storageImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    imageStore(storageImage, ivec2(gl_GlobalInvocationID.xy), vec4(uv, 0.0, 1.0));
}