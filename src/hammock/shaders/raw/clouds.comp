#version 450

#include "common/intersections.glsl"

layout (local_size_x = 32, local_size_y = 32) in;
layout (binding = 0, rgba8) uniform writeonly image2D storageImage;

// Camera type
struct Camera {
    mat4 invView; // Inverse view matrix
    vec4 position; // Camera position in world space
};

struct Sun {
    vec4 position;
    vec4 color;
};

struct Clouds {
    float absorption;
    float scattering;
    float phase;
    float density;
    float densityOffset;
};

layout (binding = 1) uniform UBO
{
    Camera camera;
    Sun sun;
    Clouds clouds;
} ubo;

layout (std140, binding = 2) buffer Scene
{
    vec4 bbMin;
    vec4 bbMax;
} storageBuffer;

layout (binding = 3) uniform sampler3D baseNoiseSampler;
layout (binding = 4) uniform sampler3D detailNoiseSampler;
layout (binding = 5) uniform sampler2D curlNoiseSampler;
layout (binding = 6) uniform sampler2D cloudMap;


#define PI 3.14159265359

const int MIN_STEPS = 64;
const int MAX_STEPS = 128;
const int LIGHT_STEPS = 6;
const int LIGHT_STEP_SIZE = 1;

// Helper function to get ray origin (camera position in this case)
vec3 getRayOrigin() {
    return ubo.camera.position.xyz;
}

// Helper function to compute ray direction
vec3 getRayDirection() {
    // Compute the UV coordinates
    ivec2 dim = imageSize(storageImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // Convert uv to normalized device coordinates (range -1 to 1)
    vec2 ndc = uv * 2.0 - 1.0;

    // Assume a field-of-view (FOV) of 45 degrees
    float fov = radians(45.0);
    float aspect = float(dim.x) / float(dim.y);
    float scale = tan(fov * 0.5);

    // Compute the ray direction in camera (view) space.
    // Here we assume the camera looks down the -Z axis.
    vec3 rayDirView = normalize(vec3(ndc.x * aspect * scale, ndc.y * scale, -1.0));

    // Transform the view-space ray direction into world space using the camera's inverse view matrix.
    // We use a 0.0 for the w component so that only rotation (and possibly scaling) is applied.
    vec3 rayDirection = normalize((ubo.camera.invView * vec4(rayDirView, 0.0)).xyz);

    return rayDirection;
}

vec3 mapWorldToSample(vec3 worldPos, vec3 bbmin, vec3 bbmax) {
    vec3 normalized = (worldPos - bbmin) / (bbmax - bbmin);
    // Debug visualization - output raw normalized coordinates
    return normalized; // This should show smooth gradients if inputs are continuous
}

// Remaps value from one range to another
float remap(float value, float inMin, float inMax, float outMin, float outMax) {
    return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin);
}



// Samples base noise at given position
vec4 sampleBaseNoise(vec3 pos) {
    return texture(baseNoiseSampler, pos);
}

// Samples detail noise at given position
vec4 sampleDetailNoise(vec3 pos) {
    return texture(detailNoiseSampler, pos);
}

// Samples curl noise at given position
vec4 sampleCurlNoise(vec2 uv) {
    return texture(curlNoiseSampler, uv);
}

float baseDensity(vec3 pos) {
    // Remap the sampling position
    vec3 uvw = mapWorldToSample(pos, storageBuffer.bbMin.xyz, storageBuffer.bbMax.xyz);

    // Sample the noise frequencies
    vec4 lowFreqNoises = sampleBaseNoise(uvw) * ubo.clouds.density * 10;

    // Build the FBM
    float lowFreqFBM = (lowFreqNoises.g * 0.625) +
    (lowFreqNoises.b * 0.25) +
    (lowFreqNoises.a * 0.125);

    // Clamp the FBM
    lowFreqFBM = clamp(lowFreqFBM, 0.0, 1.0);

    // Build the base shape by eroding low freq noise using the FBM
    // TODO remap clamped
    float baseCloud = remap(clamp(lowFreqNoises.r + ubo.clouds.densityOffset, 0.0, 1.0), (lowFreqFBM - 0.9), 1.0, 0.0, 1.0 );

    return baseCloud;

    // Cloud coverage is stored in cloud map in red channel
    vec4 cloudMap = texture(cloudMap, vec2(uvw.x, uvw.z));
    float cloudCoverage = cloudMap.r;

    float baseCloudWithCoverage = remap(baseCloud, cloudCoverage, 1.0, 0.0, 1.0);

    // To ensure that the density increases with coverage in an aesthetically pleasing manner
    // Multiply the result by the cloud coverage attribute so that smaller clouds are lighter
    // and more aesthetically pleasing
    baseCloudWithCoverage *= cloudCoverage;

    return baseCloudWithCoverage;
}


// Number of steps based on the intersection length
int computeRaymarchSteps(float chordLength, float minChord, float maxChord, int minSteps, int maxSteps) {
    // Normalize the chord length between 0 and 1.
    float t = clamp((chordLength - minChord) / (maxChord - minChord), 0.0, 1.0);
    // Interpolate between minSteps and maxSteps.
    return int(mix(float(minSteps), float(maxSteps), t));
}


float henyeyGreenstein(float cosTheta, float g) {
    return (1.0 / 4.0 * PI) * ((1 - (g * g)) / pow((1 - (g * cosTheta)), 2));
}


float lightTransmittance(vec3 pos, float cosTheta) {
    vec3 direction = normalize(ubo.sun.position.xyz - pos);

    float extinctionCoef = ubo.clouds.absorption + ubo.clouds.scattering;
    float transmittance = 1.0;

    for (int i = 0; i < LIGHT_STEPS; i++) {
        vec3 rayPos = pos + direction * (i * LIGHT_STEP_SIZE);

        float density = 0.0;
        float intersection = rayBoxDst(storageBuffer.bbMin.xyz, storageBuffer.bbMax.xyz, rayPos, direction).y;
        if (intersection > 0.0) {
            density = baseDensity(rayPos) * LIGHT_STEP_SIZE;
        }

        transmittance *= exp(-density * extinctionCoef) * henyeyGreenstein(cosTheta, ubo.clouds.phase);

        if (transmittance < 0.01) break;
    }

    return transmittance;
}


void main() {
    // Compute the UV coordinates
    ivec2 dim = imageSize(storageImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // Final color
    vec4 outColor = vec4(0.0);

    // Ray origin and direction
    vec3 rayOrigin = getRayOrigin();
    vec3 rayDirection = getRayDirection();

    vec3 ambientLight = ubo.sun.color.rgb;
    float extinctionCoef = ubo.clouds.absorption + ubo.clouds.scattering;


    // Intersect the boudning box of the atmosphere
    vec2 bboxIntersection = rayBoxDst(storageBuffer.bbMin.xyz, storageBuffer.bbMax.xyz, rayOrigin, rayDirection);
    float dstToBox = bboxIntersection.x; // Distance to the intersection
    float dstInsideBox = bboxIntersection.y; // Intersection length

    // If we intersect the clouds bounding box
    if (dstInsideBox > 0.0) {
        // Compute longest and shortest intersection lengths
        vec2 lengths = computeIntersectionLengths(storageBuffer.bbMin.xyz, storageBuffer.bbMax.xyz);
        // Compute number of steps relative to the lenght of the intersection
        float numSteps = computeRaymarchSteps(dstInsideBox, lengths.x, lengths.y, MIN_STEPS, MAX_STEPS);

        float stepSize = dstInsideBox / numSteps;

        float transmittance = 1.0;
        vec3 illumination = vec3(0.0);

        for (int i = 0; i < numSteps; i++) {
            vec3 rayPos = rayOrigin + rayDirection * (dstToBox + i * stepSize);


            float cosTheta = dot(rayDirection, normalize(ubo.sun.position.xyz - rayPos));
            float phase = henyeyGreenstein(cosTheta, ubo.clouds.phase);

            float currentDensity = baseDensity(rayPos);
            transmittance *= exp(-currentDensity * extinctionCoef * stepSize);

            float light = lightTransmittance(rayPos, cosTheta);

            vec3 inScattering = ambientLight * light * phase;
            float outScattering = ubo.clouds.scattering * currentDensity;

            vec3 currentLight = inScattering * outScattering;

            illumination += transmittance * currentLight * stepSize;

            if (transmittance < 0.01) break;
        }


        outColor = vec4(illumination, 1.0 - transmittance);

    }

    imageStore(storageImage, ivec2(gl_GlobalInvocationID.xy), outColor);
}