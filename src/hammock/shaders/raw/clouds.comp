#version 450

#include "common/intersections.glsl"

layout (local_size_x = 32, local_size_y = 32) in;
layout (binding = 0, rgba8) uniform writeonly image2D storageImage;

// Camera type
struct Camera {
    mat4 invView; // Inverse view matrix
    vec4 position; // Camera position in world space
};

struct Sun {
    vec4 position;
    vec4 color;
};

struct Rendering {
    float absorption;
    float scattering;
    float phase;
};

layout (binding = 1) uniform UBO
{
    Camera camera;
    Sun sun;
    Rendering rendergin;
} ubo;

layout (std140, binding = 2) buffer Scene
{
    vec4 bbMin;
    vec4 bbMax;
} storageBuffer;

layout (binding = 3) uniform sampler3D baseNoiseSampler;
layout (binding = 4) uniform sampler3D detailNoiseSampler;
layout (binding = 5) uniform sampler2D curlNoiseSampler;


#define PI 3.14159265359

const int MIN_STEPS = 64;
const int MAX_STEPS = 128;
const int LIGHT_STEPS = 6;
const int LIGHT_STEP_SIZE = 1;

// Helper function to get ray origin (camera position in this case)
vec3 getRayOrigin() {
    return ubo.camera.position.xyz;
}

// Helper function to compute ray direction
vec3 getRayDirection() {
    // Compute the UV coordinates
    ivec2 dim = imageSize(storageImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // Convert uv to normalized device coordinates (range -1 to 1)
    vec2 ndc = uv * 2.0 - 1.0;

    // Assume a field-of-view (FOV) of 45 degrees
    float fov = radians(45.0);
    float aspect = float(dim.x) / float(dim.y);
    float scale = tan(fov * 0.5);

    // Compute the ray direction in camera (view) space.
    // Here we assume the camera looks down the -Z axis.
    vec3 rayDirView = normalize(vec3(ndc.x * aspect * scale, ndc.y * scale, -1.0));

    // Transform the view-space ray direction into world space using the camera's inverse view matrix.
    // We use a 0.0 for the w component so that only rotation (and possibly scaling) is applied.
    vec3 rayDirection = normalize((ubo.camera.invView * vec4(rayDirView, 0.0)).xyz);

    return rayDirection;
}

vec3 mapWorldToSample(vec3 worldPos, vec3 bbmin, vec3 bbmax) {
    vec3 normalized = (worldPos - bbmin) / (bbmax - bbmin);
    // Debug visualization - output raw normalized coordinates
    return normalized; // This should show smooth gradients if inputs are continuous
}


// Samples base noise at given position
vec4 sampleBaseNoise(vec3 pos) {
    return texture(baseNoiseSampler, pos);
}

// Samples detail noise at given position
vec4 sampleDetailNoise(vec3 pos) {
    return texture(detailNoiseSampler, pos);
}

// Samples curl noise at given position
vec4 sampleCurlNoise(vec2 uv) {
    return texture(curlNoiseSampler, uv);
}

float baseDensity(vec3 pos){
    vec3 uvw = mapWorldToSample(pos, storageBuffer.bbMin.xyz, storageBuffer.bbMax.xyz);
    return sampleBaseNoise(uvw).r;
    //return 0.5;
}

// Remaps value from one range to another
float remap(float value, float inMin, float inMax, float outMin, float outMax) {
    return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin);
}

// Number of steps based on the intersection length
int computeRaymarchSteps(float chordLength, float minChord, float maxChord, int minSteps, int maxSteps) {
    // Normalize the chord length between 0 and 1.
    float t = clamp((chordLength - minChord) / (maxChord - minChord), 0.0, 1.0);
    // Interpolate between minSteps and maxSteps.
    return int(mix(float(minSteps), float(maxSteps), t));
}


float henyeyGreenstein(float cosTheta, float g){
    return (1.0 / 4.0 * PI) * ((1 - (g * g)) / pow((1 - (g * cosTheta)), 2));
}


float lightTransmittance(vec3 pos){
    vec3 direction = normalize(ubo.sun.position.xyz - pos);

    float extinctionCoef = ubo.rendergin.absorption + ubo.rendergin.scattering;
    float transmittance = 1.0;

    for(int i = 0; i < LIGHT_STEPS; i++){
        vec3 rayPos = pos + direction * (i * LIGHT_STEP_SIZE);

        float density = 0.0;
        float intersection = rayBoxDst(storageBuffer.bbMin.xyz, storageBuffer.bbMax.xyz, rayPos, direction).y;
        if(intersection > 0.0){
            density = baseDensity(rayPos);
        }

        transmittance *= exp(-density * extinctionCoef * LIGHT_STEP_SIZE);

        if(transmittance < 0.01) break;
    }

    return transmittance;
}


void main() {
    // Compute the UV coordinates
    ivec2 dim = imageSize(storageImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // Final color
    vec4 outColor = vec4(0.0);

    // Ray origin and direction
    vec3 rayOrigin = getRayOrigin();
    vec3 rayDirection = getRayDirection();

    vec3 ambientLight = ubo.sun.color.rgb;
    float extinctionCoef = ubo.rendergin.absorption + ubo.rendergin.scattering;


    // Intersect the boudning box of the atmosphere
    vec2 bboxIntersection = rayBoxDst(storageBuffer.bbMin.xyz, storageBuffer.bbMax.xyz, rayOrigin, rayDirection);
    float dstToBox = bboxIntersection.x; // Distance to the intersection
    float dstInsideBox = bboxIntersection.y; // Intersection length

    // If we intersect the clouds bounding box
    if (dstInsideBox > 0.0){
        // Compute longest and shortest intersection lengths
        vec2 lengths = computeIntersectionLengths(storageBuffer.bbMin.xyz, storageBuffer.bbMax.xyz);
        // Compute number of steps relative to the lenght of the intersection
        float numSteps = computeRaymarchSteps(dstInsideBox, lengths.x, lengths.y, MIN_STEPS, MAX_STEPS);

        float stepSize = dstInsideBox / numSteps;

        float transmittance = 1.0;
        vec3 illumination = vec3(0.0);

        for(int i = 0; i < numSteps; i++){
            vec3 rayPos = rayOrigin + rayDirection * (dstToBox + i * stepSize);


            float phase = henyeyGreenstein(dot(rayDirection, normalize(ubo.sun.position.xyz - rayPos)), ubo.rendergin.phase);

            float currentDensity = baseDensity(rayPos);
            transmittance *= exp(-currentDensity * extinctionCoef * stepSize);

            float light = lightTransmittance(rayPos);

            vec3 inScattering = ambientLight * light * phase;
            float outScattering = ubo.rendergin.scattering * currentDensity;

            vec3 currentLight = inScattering * outScattering;

            illumination += transmittance * currentLight * stepSize;

            if(transmittance < 0.01) break;
        }


        outColor = vec4(illumination, transmittance);

    }

    imageStore(storageImage, ivec2(gl_GlobalInvocationID.xy), outColor);
}